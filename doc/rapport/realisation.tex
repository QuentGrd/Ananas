\newpage
\section{Réalisation}
\label{sec:impl}

%\begin{figure}
%\centering
%\includegraphics[width=3.5cm, height=2cm]{images/programmer.png}
%\caption{Un programmeur occupé}
%\label{fig:modele}
%\end{figure}

\subsection{ Le model - présentation des classes }

\subsubsection{ La ville }

\label{real_model}
\paragraph{}La ville est le premier élément qui constitue notre projet. Elle est composé de différentes infrastructures : Les routes, les maison, les bâtiments de travail et les divertissement. Chaque type d'infrastructure possède une utilité qui lui est propre :
\begin{itemize}
\item Les Routes permettent aux personnages de se déplacer
\item Les Maisons permettent aux personnages de se reposer le soir et regagner de l'émotion
\item Le Travail est une activité imposé à chaque personnages et sera la principale source de baisse d'émotion
\item Les Divertissement permettent aux personnages lorsqu'ils ne dorment pas de regagner de l'émotion
\end{itemize}
\begin{figure}[H]
	\centering
		\includegraphics[width=0.75\textwidth]{images/data.png}
		\caption{Diagramme UML des composantes de la ville}
	\label{fig:data_ville}
\end{figure}
\paragraph{}Toutes les infrastructures possèdent en commun : 
\begin{itemize}
\item Un nom de type String
\item Un type au format int
\item Une position dans la Map
\item Un taille
\item Et un nombre d'utilisateur courant
\end{itemize}
\paragraph{}Et les bâtiments (hors routes) possèdent tous en commun ces caractéristiques :
\begin{itemize}
\item Une adresse, seule point d'entré dans le bâtiments au niveau de la Map
\item Une récompense, qui peut être positive ou négative suivant le type de bâtiment
\item Un nombre maximum d'utilisateur 
\end{itemize}
\paragraph{}En plus de ces caractéristiques, les bâtiments de travail et les divertissement possède un temps d'utilisation moyen par les personnages, ainsi que des horaires d'ouvertures durant lesquelles les personnages pourront utiliser ces bâtiments. Il est également impossible pour un personnages d'utiliser un bâtiments lorsque celui ci à atteint son nombre maximum d'utilisateur. Les routes et les maisons sont ouverts 24h/24.
\paragraph{}La taille de la Map ainsi que la répartition des infrastructures est déterminé à l'avance dans un fichier CSV. La création de la Map dans la mémoire se fait grâce au pattern design Builder. Chaque ligne du fichier CSV renseigne, le type, l'adresse, la taille et sa position dans la Map. Ainsi l'objet MapBuilder va lire les lignes du fichier une par une grâce à la bibliothèque Apache Common CSV, et faire appelle au autres Builder correspondant à chaque type d'infrastructure.
\paragraph{}Durant leur création, les Infrastructures de type Work ou Entertainement, se voient également attribuer un nom, des horaires d'ouvertures et leur récompenses. Ces informations sont aussi renseigné à l'avance dans un fichier CSV.
\begin{figure}[H]
	\centering
		\includegraphics[width=0.75\textwidth]{images/builders.png}
		\caption{Diagramme UML de la construction de la ville}
	\label{fig:data_builders}
\end{figure}

\subsubsection{ La population }
\paragraph{}
La population est le second ensemble qui constitue notre projet. 
Nous l'avons voulu le plus adaptatif possible.
Cependant la création de la population depend de la ville car, pour le mode normal, chaque maison ainsi que chaque lieu de travail ne peut contenir qu'un seul personnage (par soucis de réalisme et de bonne répartition de la population sur la carte). 
Pour le mode autonome, au lancement du jeu, chaque maison ne peut avoir qu'un seul personnage. Au cours de l'evolution de la population plusieurs personnages pourront habiter dans une même maison.
Notre population est donc limitée à 15 personnages maximum pour le mode normal (car 15 batiments de travail) et 60 en mode autonome (car 60 maisons)
Si l'on décide d'aumenter la taille de la ville ou d'enlever les limitations de personnages par maison, la ville pourrait contenir une plus grande population. 
Cependant, une trop grande population provoquera des ralentissement de l'interface graphique mais le moteur de jeu est parfaitement capable de faire tourné une grande population. 

\begin{table}[h!]
\centering
\begin{tabular} {|p{3.5cm}|p{3.5cm}|p{5cm}|}
\hline
Mode normale & Mode autonome \\
\hline
niveau easy : 1 & [1 - 60] \\
\hline
niveau normale : 3 \\
\hline
niveau hard : 5 \\
\hline
niveau pro : 15 \\
\hline
\end{tabular}
\caption{Taille de la population}
\label{tab:document}
\end{table}

\paragraph{Création des personnages}
Un personnage est composé d'information de base comme d'un nom, d'un prénom, d'un sexe , d'un age et d'un numéro d'identité.

\begin{figure}[H]
\centering
\includegraphics[width=7cm, height=5cm]{images/car.jpg}
\caption{Classe abstraite Character}
\label{fig:modele}
\end{figure}

\paragraph{}
Pour le nom, le prénom et le sexe du personnage, ils sont initialisés à partir de fichier CSV. 
Le premier fichier contient une liste de 300 noms de familles et le second une liste de 200 prénoms, 100 masculin et 100 féminin. 
Lors de la création du personnage, le programme va prendre au hasard un nom dans le fichier name.csv et un prénom (associé à un sexe) dans le fichier firstName.csv. 
L'age du personnage est simplement choisit aléatoirement entre 10 et 100 ans. 
Le numéro d'identité du personnage est unique, il est calculé à partir de toutes les informations du personnage grâce à un code de hashage. 
Ce code nous permettra de reconnaître le personnage. 
Ce grand nombre de choix nous permet de garantie une grande diversité au sein de la population.

\paragraph{}
Comme le montre la figure 1, un personnage possède également une maison. 
Cet élément est également attribué aléatoirement via une recherche dans la liste de lieux d'habitation de la carte de jeu.

\paragraph{}
Un personnage possède également un tableau de jauges contenant :
\begin{itemize}
 \item une jauge d'émotion 
 \item une jauge d'argent 
 \item une jauge de famille
\end{itemize}

\paragraph{}
Ces jauges peuvent varier de 0 à 100. 
Ces jauges représentent les critères de vie du personnage. Elle est initialisé à 75 en début de partie mais elle variera en fonctions des actions des personnages. 
Si l'une des jauges du personnage arrive à 0 il meurt.

\paragraph{}
Nous avons voulu rendre nos personnages le moins statique possible. 
Ainsi d'une partie à l'autre, la chance de tomber sur des personnages avec les mêmes propriétés est très faible.

\paragraph{Les différents types de personnages}
La classe abstraite Character possède deux classes filles avec des fonctionnalités différentes. 
La premiere, NCharacter, représente les personnages utilisés dans le mode de jeu normal. 
La seconde, QCharacter, représente les personnages utilisés dans le mode de jeu autonome.

\begin{figure}[H]
\centering
\includegraphics[width=9cm, height=7cm]{images/carTree.png}
\caption{Classe abstraite Character et ses classes filles}
\label{fig:modele}
\end{figure}

\paragraph{}
Les NCharacters possèdent un lieu de travail qui est attribué aléatoirement via une recherche dans la liste des lieux de travail de la carte en debut de jeu.
Ils possèdent également un objet de classe DataCharacter pour sauvegarder des données sur le personnage pendant le jeu (voir partie statistique de jeu).
Enfin, les NCharacter possèdent une routine, une liste d'actions qu'il executera tout les jours. (voir routine partie moteur)

\paragraph{}
Les QCharacters possèdent une position initiale qui sera leur maison à chaque réaparition pour leur permettre d'y retourner en cas de besoin de sommeil.
Ils possèdent également un environement qui est une représentation binaire de la carte (0 si la case est praticable, 1 si c'est un obstacle). 
Cet environnement est couplé à un etat courant qui représente la position courante du personnage dans la carte simplifié.
On compte également le nombre de mort de chaque personnage pour faire des statisqtiques avec .
Enfin, un QCharacter possède une liste de coordonnées qui lui permettra de retourner à sa maison si il à un besoin en sommeil.

\paragraph{Organisation de la création de la population}
La création des personnages se fait grâce au design pattern builder (figure 5).

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/popN.png}
\caption{Architecture de création des NCharacters et de la population}
\label{fig:modele}
\end{figure}

\paragraph{}
La classe PopulationBuilder va construire une population grâce à la carte de jeu (pour assigner les résidences) et grâce au CharacterBuilder. 
Ce dernier va faire la lecture dans les fichiers CSV grâce à la bibliothèque Apache-commons-csv et va faire les choix aléatoires pour initialiser les différentes composantes de nos personnages.

\paragraph{}
On utilise la meme architecture pour créer la population de QCharacter dans le mode autonome.


\subsection{Le moteur de jeu : mode normale}
\subsubsection{Gestion des jauges des personnages}

\paragraph{}
Les jauges représentent les critères de vie des personnages, elles varient de 0 à 100 avec le temps. 
Si l'une d'elles atteint 0, le personnage meurt. 
L'évolution de ces jauges est totalement dynamique, elle se fera automatiquement en fonction des actions faites par le personnage. 
Certaines actions vont apporter un bonus différent sur les jauges du personnage alors que d'autres vnt apporter des malus. 
Pour certaines actions le bonus est constant (par exemple dormir apportera toujours +30 en famille) mais pour d'autres le bonus/malus est variable en fonction du lieu dans lequel se fait l'action. 
Par exemple travailler dans un atelier auto apportera un malus de -25 en émotion car la tache est difficile alors que travailler dans une boutique d'électronique apportera un malus de -15. 
Même fonctionnement pour les bonus des loisirs. 
Ces valeurs sont initialiser lors que l'initialisation des bâtiments, elles proviennent donc d'un fichiers CSV. 
Enfin les rewards de sont pas toujours effectif au même moment. 
Pour la plupart des actions, le personnage perçoit le reward en fin d'action. 
Pour l'action de déplacement, dans un soucis de mieux représenter la réalité, le malus est retiré à chaque itération de temps. 
C'est à dire que plus le chemin que le personnage a à faire est long, plus il perd de l'émotion.

\begin{table}[H]
\centering
\begin{tabular} {|p{1.5cm}|p{4cm}|p{3.5cm}|p{1.5cm}|p{5cm}|}
\hline
Action & Emotion & Money & famille & Effectivité \\
\hline
Sleeping & +15 & 0 & +30 & En fin d'action\\
\hline
Chilling & 0 & 0 & +5 & En fin d'action\\
\hline
Shifting & -1 & -0.33 & -0.33 & A chaque itération de temps\\
\hline
Working & Malus variable \newline{[-25;-10]} & Bonus variable \newline{[+15;+30]} & -5 & En fin d'action \\
\hline
Entertain & Bonus variable \newline{[+5;+20]} & Malus variable \newline{[-15;0]} & -5 & En fin d'action \\
\hline
\end{tabular}
\caption{Répartition des rewards}
\label{tab:document}
\end{table}

\subsubsection{Gestion de la routine}

\paragraph{}
La routine est un enchaînement d'actions que va exécuter le personnage. 
Le personnage peut exécuter 5 types d'actions différentes regrouper en familles : les déplacements et les occupations.  
Les actions d'occupation sont reliées à un lieu alors que les actions de déplacement sont reliées à un lieu de départ, un lieu d'arrivé et un chemin entre les deux.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/routine.jpg}
\caption{Architecture de gestion des routines}
\label{fig:modele}
\end{figure}

\paragraph{}
L'un des dilemme du projet est l'interaction entre les différentes actions pour  que chaque personnage puisse suivre une suite d'actions indépendantes mais que l'utilisateur puisse ajouter des actions a faire sans perturber le bonne enchaînement des actions.

\paragraph{}
Nous avons décidé de décomposer ce problème en 3 partie :
\begin{itemize}
 \item Une partie statique qui organise les grandes lignes des journées du personnage : métro/boulot/dodo
 \item Une partie dynamique qui évolue au court de la journée et qui représente la liste d'actions que le personnage a à faire
 \item Une partie utilisateur associé à différente options d'ajout/suppression d'actions 
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{images/schemaRoutine.PNG}
\caption{Architecture de gestion des routines}
\label{fig:modele}
\end{figure}

\paragraph{}
La liste d'actions communes a chaque journées est stocké dans la liste DailyRoutine. 
A chaque début de journée, on ajoute toutes les actions de cette liste a celle de la journée courante, CurentRoutine. 
La currentRoutine à les même propriétés qu'une files mais avec plus de possibilité d'ajout d'actions. 
On défile currentRoutine et on ajoute cette action à l'action courante, currentAction. 
Cette action est exécuté par le personnage et lorsqu'elle est finie, on défile à nouveau la currentRoutine. 
Enfin l'utilisateur peut soit ajouter un action en tête ou en queue dans la currentRoutine.

\subsubsection{Gestion des itinéraires : Algorithme A*}

\paragraph{}
L'utilisateur peut demander à un personnage de se deplacer d'un point A à un point B mais il n'a pas besoin de lui spécifier exactement le chemin à faire.
En effet le personnage est capable de trouver le chemin le plus court pour aller d'un point A à un point B grâce à l'algorithme de path founding A*.

\paragraph{Fonctionnement de l'algorithme}
Le principe de l'agorithme est de toujours se rapprocher le plus possible du point d'arrivé.
Cependant on n'oublie pas les solutions qui nous éloignent directement de l'ojectif car elles pourraient faire partie du chemin final.
On représente notre carte sous forme de graph avec des noeud praticable (routes et entrées de batiments) et des noeud obstacle (batiments).

\paragraph{}
On utilisera 2 liste chainées : 
\begin{itemize}
 \item une liste ouverte contenant tout les noeuds étudiés
 \item une liste fermé contenant les noeuds qui semblent faire partie du chemin solution. 
\end{itemize}
Pour noter la pertinance d'un noeud, on calcul sa distance à vol d'oiseau au carré avec l'objectif grâce à l'équation : 
\[P = (x_{arrivee} - x_{debut})^2 + (y_{arrivee} - y_{debut})^2\]

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/Astar.png}
\caption{A* : calcul de la pertinance d'un noeud}
\label{fig:modele}
\end{figure}

\paragraph{}
Enfin on repète les étapes suivantes pour construire le chemin solution :
\begin{enumerate}
 \item On prend comme noeud courant le noeud de départ
 \item On regarde tout les noeuds voisins
 \item \begin{itemize}
        \item Si un noeud voisin est un obstacle, on l'oublie
        \item Si un noeud voisin est déjà dans la liste fermé, on l'oublie
        \item Si le noeud voisin est dans la liste ouverte, on le met à jour si il a une meilleur pertinance que celui déjà présent dans la liste ouverte (on change sa pertinance et ses parents)
        \item Sinon, on ajoute le noeud voisin dans la liste ouverte avec comme noeud parent le noeud courant
       \end{itemize}
 \item On cherche le meilleur noeud de toute la liste ouverte (si cette derniere est vide, pas de solution, fin de l'algorithme)
 \item On le met dans la liste fermé et on le retire de la liste ouverte
 \item Ce noeud devient le noeud courant et on recommence (sauf si c'est le noeud d'arrivé, fin de l'algorithme)
\end{enumerate}

\paragraph{}
Pour récupérer le chemin optimal il suffi juste de prend le noeud et de regarder succecivement tout les parents jusqu'au point de départ.
\paragraph{}
Cet algorithme nous assure de trouver le chemin optimal pour nos personnages.

\subsubsection{Collecte de données statisqtiques}
\paragraph{}
Pour permettre au joueur d'élaborer des stratégies et d'avoir une meilleure vision sur les actions passé des personnages, il a à sa disposition un certain nombre de statistiques.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/graph.png}
\caption{Statistiques pour chaque peronnage}
\label{fig:modele}
\end{figure}

\paragraph{}
Il peut accéder à :
\begin{itemize}
 \item La répartition des différents types d'actions depuis le début du jeu
 \item La comparaison entre la répartition des types d'actions de la journée courante et celle de la journée précédente
 \item L'évolution des 3 jauges depuis le début du jeu.
 \item La comparaison de l'évolution de l'émotion entre la journée courante et la journée précédente
 \item La répartition des rewards en émotion (reward positif, reward négatif, reward nul)
\end{itemize}

\paragraph{}
Toutes ces statistiques sont gérées par le moteur et sont stockées dans l'objet dataCharacter de chaque personnages.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{images/dataCharacter.png}
\caption{Classe DataCharacter}
\label{fig:modele}
\end{figure}

\subsubsection{Fin de partie : enregistrement du score}
\paragraph{}
A la fin de la partie ou quand le joueur décide de revenir au menu, le jeu lui propose d'enregister son score sur notre site internet (voir partie leaderboard).
Son score est calculé en fonction du temps de jeu.
Plus longtemps il réussira à faire vivre sa population, plus son score sera grand. 
Une fois son score enregitré, le moteur génère une URL renvoyant vers notre site et contenant le niveau de difficulté et le score réalisé. 
Ces données seront interprété par un formulaire sur le site et le score pourra être enregistré.
Si l'utilisateur veux directement refaire une partie et ne pas perdre de temps à enregistrer son score sur sa machine de jeu, il peut scanner un QRCode avec son téléphone pour accéder à la version mobile du site.
Il peut ainsi enregistrer son score sur son téléphone en même temps de refaire une nouvelle partie sur sa machine de jeu.
\paragraph{Le QRCode}
est une conversion en binaire d'une chaine de caractères. Ce code binaire est ensuite convertit  sous format image : les petit carrés noir représente les 1 et les blancs les 0.
Nous transformons donc notre URL en QRCode grâce à la bibliothèque Zxing de Google.
Lors du scanne, le lecteur de QRCode proposera à l'utilisateur de suivre le lien vers notre site afin de s'enregistrer. 

\subsection{Le moteur de jeu : mode autonome}

\subsection{Logging : Log4J}
\paragraph{}
Afin de suivre la bonne création de la carte de jeu et de la création de la population nous avons suivi les étapes clefs ces créations  par un système de logging.
Les principales étapes qui sont suivies sont :
\begin{itemize}
 \item La lecture dans les fichiers CSV (pour les batiments et les personnages)
 \item Les bon positionnement des batiments dans la carte
 \item La bonne initialisation des routines
\end{itemize}
\paragraph{}
Pour ce faire nous utilisons l'outils de logging Log4J.


\subsection{Phase de test}
\paragraph{}
Pour garantire un parfait fonctionnement de notre logiciel nous avons mis en place une phase de test composée de 4 tests différents.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{images/test.PNG}
\caption{Fonctionnement de notre phase de test}
\label{fig:modele}
\end{figure}

\paragraph{Test unitaire}
Grâce à l'outils JUnit nous réalisons des tests unitaires pour garantir :
\begin{itemize}
 \item Création de la population (lecture CSV, tirage aléatoire, initialisation de la routine)
 \item Test de l'algorithme A* (simulation de plusieur trajet et vérification de l'existance du chemin resultat)
\end{itemize}

\paragraph{Test de robustesse}
Nous avons également réalisé des test de cas critiques (augmentation de la population au maximum, ajout d'actions au moment critique ...)
Nous n'avons relevé aucun problème à ce niveau.

\paragraph{Test de performance}
Nous avons suivi l'evolution de la consommation CPU tout au long de projet. 
Ce suivi nous a permis de déceler un problème de rafraichissement des images et de baisser la consommation de notre jeu.
Cependant nous remarquons que notre jeu consomme beaucoup que ce soit en mode normale ou en mode autonome.
Nous avons fait tourner le moteur indépendament dans des conditions critique (population au maximum) et il s'avère que ce n'est pas le moteur qui cause cette forte consommation.
Nous arrivons donc à la conclusion que le problème vient de l'interface graphique mais nous n'arrivons pas à identifier précisement le problème.

\paragraph{Test d'ergonomie}
Nous avons fait tester notre jeu à un panel (composé de quelques camarades de classe) pour optenir des feedback sur le jeu.
Tout les retours que nous avons collectés montre que le design de l'application est bien reçu par l'utilisateur.
Cependant, certains retour on noté une fragilité du gamePlay de notre jeu.


\input{real_ihm.tex}
\input{real_leaderboard.tex}