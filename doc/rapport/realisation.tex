\newpage
\section{Réalisation}
\label{sec:impl}

%\begin{figure}
%\centering
%\includegraphics[width=3.5cm, height=2cm]{images/programmer.png}
%\caption{Un programmeur occupé}
%\label{fig:modele}
%\end{figure}

\subsection{ Le model - présentation des classes }

\subsubsection{ La ville }

\label{real_model}
\paragraph{}La ville est le premier élément qui constitue notre projet. Elle est composé de différentes infrastructures : Les routes, les maison, les bâtiments de travail et les divertissement. Chaque type d'infrastructure possède une utilité qui lui est propre :
\begin{itemize}
\item Les Routes permettent aux personnages de se déplacer
\item Les Maisons permettent aux personnages de se reposer le soir et regagner de l'émotion
\item Le Travail est une activité imposé à chaque personnages et sera la principale source de baisse d'émotion
\item Les Divertissement permettent aux personnages lorsqu'ils ne dorment pas de regagner de l'émotion
\end{itemize}
\begin{figure}[H]
	\centering
		\includegraphics[width=0.75\textwidth]{images/data.png}
		\caption{Diagramme UML des composantes de la ville}
	\label{fig:data_ville}
\end{figure}
\paragraph{}Toutes les infrastructures possèdent en commun : 
\begin{itemize}
\item Un nom de type String
\item Un type au format int
\item Une position dans la Map
\item Un taille
\item Et un nombre d'utilisateur courant
\end{itemize}
\paragraph{}Et les bâtiments (hors routes) possèdent tous en commun ces caractéristiques :
\begin{itemize}
\item Une adresse, seule point d'entré dans le bâtiments au niveau de la Map
\item Une récompense, qui peut être positive ou négative suivant le type de bâtiment
\item Un nombre maximum d'utilisateur 
\end{itemize}
\paragraph{}En plus de ces caractéristiques, les bâtiments de travail et les divertissement possède un temps d'utilisation moyen par les personnages, ainsi que des horaires d'ouvertures durant lesquelles les personnages pourront utiliser ces bâtiments. Il est également impossible pour un personnages d'utiliser un bâtiments lorsque celui ci à atteint son nombre maximum d'utilisateur. Les routes et les maisons sont ouverts 24h/24.
\paragraph{}La taille de la Map ainsi que la répartition des infrastructures est déterminé à l'avance dans un fichier CSV. La création de la Map dans la mémoire se fait grâce au pattern design Builder. Chaque ligne du fichier CSV renseigne, le type, l'adresse, la taille et sa position dans la Map. Ainsi l'objet MapBuilder va lire les lignes du fichier une par une grâce à la bibliothèque Apache Common CSV, et faire appelle au autres Builder correspondant à chaque type d'infrastructure.
\paragraph{}Durant leur création, les Infrastructures de type Work ou Entertainement, se voient également attribuer un nom, des horaires d'ouvertures et leur récompenses. Ces informations sont aussi renseigné à l'avance dans un fichier CSV.
\begin{figure}[H]
	\centering
		\includegraphics[width=0.75\textwidth]{images/builders.png}
		\caption{Diagramme UML de la construction de la ville}
	\label{fig:data_builders}
\end{figure}

\subsubsection{ La population }
\paragraph{}
La population est le second ensemble qui constitue notre projet. 
Nous l'avons voulu le plus adaptatif possible.
Cependant la création de la population depend de la ville car, pour le mode normal, chaque maison ainsi que chaque lieu de travail ne peut contenir qu'un seul personnage (par soucis de réalisme et de bonne répartition de la population sur la carte). 
Pour le mode autonome, au lancement du jeu, chaque maison ne peut avoir qu'un seul personnage. Au cours de l'evolution de la population plusieurs personnages pourront habiter dans une même maison.
Notre population est donc limitée à 15 personnages maximum pour le mode normal (car 15 batiments de travail) et 60 en mode autonome (car 60 maisons)
Si l'on décide d'aumenter la taille de la ville ou d'enlever les limitations de personnages par maison, la ville pourrait contenir une plus grande population. 
Cependant, une trop grande population provoquera des ralentissement de l'interface graphique mais le moteur de jeu est parfaitement capable de faire tourné une grande population. 

\begin{table}[h!]
\centering
\begin{tabular} {|p{3.5cm}|p{3.5cm}|p{5cm}|}
\hline
Mode normale & Mode autonome \\
\hline
niveau easy : 1 & [1 - 60] \\
\hline
niveau normale : 3 \\
\hline
niveau hard : 5 \\
\hline
niveau pro : 15 \\
\hline
\end{tabular}
\caption{Taille de la population}
\label{tab:document}
\end{table}

\paragraph{Création des personnages}
Un personnage est composé d'information de base comme d'un nom, d'un prénom, d'un sexe , d'un age et d'un numéro d'identité.

\begin{figure}[H]
\centering
\includegraphics[width=7cm, height=5cm]{images/car.jpg}
\caption{Classe abstraite Character}
\label{fig:modele}
\end{figure}

\paragraph{}
Pour le nom, le prénom et le sexe du personnage, ils sont initialisés à partir de fichier CSV. 
Le premier fichier contient une liste de 300 noms de familles et le second une liste de 200 prénoms, 100 masculin et 100 féminin. 
Lors de la création du personnage, le programme va prendre au hasard un nom dans le fichier name.csv et un prénom (associé à un sexe) dans le fichier firstName.csv. 
L'age du personnage est simplement choisit aléatoirement entre 10 et 100 ans. 
Le numéro d'identité du personnage est unique, il est calculé à partir de toutes les informations du personnage grâce à un code de hashage. 
Ce code nous permettra de reconnaître le personnage. 
Ce grand nombre de choix nous permet de garantie une grande diversité au sein de la population.

\paragraph{}
Comme le montre la figure 1, un personnage possède également une maison. 
Cet élément est également attribué aléatoirement via une recherche dans la liste de lieux d'habitation de la carte de jeu.

\paragraph{}
Un personnage possède également un tableau de jauges contenant :
\begin{itemize}
 \item une jauge d'émotion 
 \item une jauge d'argent 
 \item une jauge de fatigue
\end{itemize}

\paragraph{}
Ces jauges peuvent varier de 0 à 100. 
Ces jauges représentent les critères de vie du personnage. Elle est initialisé à 75 en début de partie mais elle variera en fonctions des actions des personnages. 
Si l'une des jauges du personnage arrive à 0 il meurt.

\paragraph{}
Nous avons voulu rendre nos personnages le moins statique possible. 
Ainsi d'une partie à l'autre, la chance de tomber sur des personnages avec les mêmes propriétés est très faible.

\paragraph{Les différents types de personnages}
La classe abstraite Character possède deux classes filles avec des fonctionnalités différentes. 
La premiere, NCharacter, représente les personnages utilisés dans le mode de jeu normal. 
La seconde, QCharacter, représente les personnages utilisés dans le mode de jeu autonome.

\begin{figure}[H]
\centering
\includegraphics[width=9cm, height=7cm]{images/carTree.png}
\caption{Classe abstraite Character et ses classes filles}
\label{fig:modele}
\end{figure}

\paragraph{}
Les NCharacters possèdent un lieu de travail qui est attribué aléatoirement via une recherche dans la liste des lieux de travail de la carte en debut de jeu.
Ils possèdent également un objet de classe DataCharacter pour sauvegarder des données sur le personnage pendant le jeu (voir partie statistique de jeu).
Enfin, les NCharacter possèdent une routine, une liste d'actions qu'il executera tout les jours. (voir routine partie moteur)

\paragraph{}
Les QCharacters possèdent une position initiale qui sera leur maison à chaque réaparition pour leur permettre d'y retourner en cas de besoin de sommeil.
Ils possèdent également un environement qui est une représentation binaire de la carte (0 si la case est praticable, 1 si c'est un obstacle). 
Cet environnement est couplé à un etat courant qui représente la position courante du personnage dans la carte simplifié.
On compte également le nombre de mort de chaque personnage pour faire des statisqtiques avec .
Enfin, un QCharacter possède une liste de coordonnées qui lui permettra de retourner à sa maison si il à un besoin en sommeil.

\paragraph{Organisation de la création de la population}
La création des personnages se fait grâce au design pattern builder (figure 5).

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/popN.png}
\caption{Architecture de création des NCharacters et de la population}
\label{fig:modele}
\end{figure}

\paragraph{}
La classe PopulationBuilder va construire une population grâce à la carte de jeu (pour assigner les résidences) et grâce au CharacterBuilder. 
Ce dernier va faire la lecture dans les fichiers CSV grâce à la bibliothèque Apache-commons-csv et va faire les choix aléatoires pour initialiser les différentes composantes de nos personnages.

\paragraph{}
On utilise la meme architecture pour créer la population de QCharacter dans le mode autonome.


\subsection{Le moteur de jeu : mode normale}
\subsubsection{Gestion des jauges des personnages}

\paragraph{}
Les jauges représentent les critères de vie des personnages, elles varient de 0 à 100 avec le temps. 
Si l'une d'elles atteint 0, le personnage meurt. 
L'évolution de ces jauges est totalement dynamique, elle se fera automatiquement en fonction des actions faites par le personnage. 
Certaines actions vont apporter un bonus différent sur les jauges du personnage alors que d'autres vnt apporter des malus. 
Pour certaines actions le bonus est constant (par exemple dormir apportera toujours +30 en fatigue) mais pour d'autres le bonus/malus est variable en fonction du lieu dans lequel se fait l'action. 
Par exemple travailler dans un atelier auto apportera un malus de -25 en fatigue car la tache est difficile alors que travailler dans une boutique d?électronique apportera un malus de -15. 
Même fonctionnement pour les bonus des loisirs. 
Ces valeurs sont initialiser lors que l'initialisation des bâtiments, elles proviennent donc d'un fichiers CSV. 
Enfin les rewards de sont pas toujours effectif au même moment. 
Pour la plupart des actions, le personnage perçoit le reward en fin d'action. 
Pour l'action de déplacement, dans un soucis de mieux représenter la réalité, le malus est retiré à chaque itération de temps. 
C'est à dire que plus le chemin que le personnage a à faire est long, plus il perd de l'émotion.

\begin{table}[H]
\centering
\begin{tabular} {|p{1.5cm}|p{4cm}|p{3.5cm}|p{1.5cm}|p{5cm}|}
\hline
Action & Emotion & Money & fatigue & Effectivité \\
\hline
Sleeping & +15 & 0 & +30 & En fin d'action\\
\hline
Chilling & 0 & 0 & +5 & En fin d'action\\
\hline
Shifting & -1 & -0.33 & -0.33 & A chaque itération de temps\\
\hline
Working & Malus variable \newline{[-25;-10]} & Bonus variable \newline{[+15;+30]} & -5 & En fin d'action \\
\hline
Entertain & Bonus variable \newline{[+5;+20]} & Malus variable \newline{[-15;0]} & -5 & En fin d'action \\
\hline
\end{tabular}
\caption{Répartition des rewards}
\label{tab:document}
\end{table}

\subsubsection{Gestion de la routine}

\paragraph{}
La routine est un enchaînement d'actions que va exécuter le personnage. 
Le personnage peut exécuter 5 types d'actions différentes regrouper en familles : les déplacements et les occupations.  
Les actions d'occupation sont reliées à un lieu alors que les actions de déplacement sont reliées à un lieu de départ, un lieu d'arrivé et un chemin entre les deux.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/routine.jpg}
\caption{Architecture de gestion des routines}
\label{fig:modele}
\end{figure}

\paragraph{}
L'un des dilemme du projet est l'interaction entre les différentes actions pour  que chaque personnage puisse suivre une suite d'actions indépendantes mais que l'utilisateur puisse ajouter des actions a faire sans perturber le bonne enchaînement des actions.

\paragraph{}
Nous avons décidé de décomposer ce problème en 3 partie :
\begin{itemize}
 \item Une partie statique qui organise les grandes lignes des journées du personnage : métro/boulot/dodo
 \item Une partie dynamique qui évolue au court de la journée et qui représente la liste d'actions que le personnage a à faire
 \item Une partie utilisateur associé à différente options d'ajout/suppression d'actions 
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{images/schemaRoutine.PNG}
\caption{Architecture de gestion des routines}
\label{fig:modele}
\end{figure}

\paragraph{}
La liste d'actions communes a chaque journées est stocké dans la liste DailyRoutine. 
A chaque début de journée, on ajoute toutes les actions de cette liste a celle de la journée courante, CurentRoutine. 
La currentRoutine à les même propriétés qu'une files mais avec plus de possibilité d'ajout d'actions. 
On défile currentRoutine et on ajoute cette action à l'action courante, currentAction. 
Cette action est exécuté par le personnage et lorsqu'elle est finie, on défile à nouveau la currentRoutine. 
Enfin l'utilisateur peut soit ajouter un action en tête ou en queue dans la currentRoutine.

\input{real_ihm.tex}
\input{real_leaderboard.tex}